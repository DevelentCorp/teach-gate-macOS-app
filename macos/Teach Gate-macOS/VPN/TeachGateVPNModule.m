#import "TeachGateVPNModule.h"
#import <NetworkExtension/NetworkExtension.h>

// Import OutlineTunnel Swift bridging header directly
// This is generated by SPM and contains OutlineVpn class definitions
#import "OutlineTunnel-Swift.h"

static NSString *const kEventVpnStatusChanged = @"vpnStatusChanged";
static NSString *const kEventVpnError = @"vpnError";
static NSString *const kDefaultTunnelId = @"TeachGateServer";
static NSString *const kDefaultDisplayName = @"Teach Gate VPN";

@interface TeachGateVPNModule ()
@property(nonatomic, assign) BOOL hasListeners;
@end

@implementation TeachGateVPNModule

RCT_EXPORT_MODULE(TeachGateVPNModule);

+ (BOOL)requiresMainQueueSetup {
  // NETunnelProviderManager and NEVPN APIs are UI-permission sensitive; safest on main.
  return YES;
}

- (NSArray<NSString *> *)supportedEvents {
  return @[kEventVpnStatusChanged, kEventVpnError];
}

- (void)startObserving {
  self.hasListeners = YES;
}

- (void)stopObserving {
  self.hasListeners = NO;
}

- (instancetype)init {
  if (self = [super init]) {
    // Subscribe to OutlineVpn status changes and forward to RN.
#ifdef __IPHONE_13_0
#endif
#ifdef __has_include
#endif
#if 1  // OutlineTunnel is directly imported above
    // Use the ObjC-bridged observer to avoid Swift closure bridging issues.
    [[OutlineVpn shared] onVpnStatusChangeObjc:^(__unused NSInteger statusValue, NSString * _Nonnull tunnelId) {
      [self emitStatusFromStatus:(NEVPNStatus)statusValue tunnelId:tunnelId];
    }];
#endif
  }
  return self;
}

#pragma mark - Exported Methods

RCT_EXPORT_METHOD(connect:(NSString *)configJson
                  resolver:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
#if 1  // OutlineTunnel is directly imported above
  NSString *transportYAML = [self toTransportYAML:configJson];
  if (transportYAML.length == 0) {
    if (reject) reject(@"invalid_config", @"Configuration string is empty or invalid", nil);
    return;
  }
  // Start the VPN via OutlineVpn (bridged async function with completion handler).
  [[OutlineVpn shared] startWithCompletion:kDefaultTunnelId
                                     named:kDefaultDisplayName
                             withTransport:transportYAML
                         completionHandler:^(NSError * _Nullable error) {
    if (error) {
      [self emitError:error forOperation:@"connect"];
      if (reject) reject([self errorCodeFromNSError:error], [self errorMessageFromNSError:error], error);
      return;
    }
    if (resolve) resolve(@(YES));
  }];
#else
  if (reject) reject(@"missing_outlinelib", @"OutlineAppleLib is not linked to the host app target", nil);
#endif
}

RCT_EXPORT_METHOD(disconnect:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
#if 1  // OutlineTunnel is directly imported above
  // Stop has no completion handler; it triggers NEVPNStatusDidChange notifications.
  [[OutlineVpn shared] stopWithId:kDefaultTunnelId];
  if (resolve) resolve(@(YES));
#else
  if (reject) reject(@"missing_outlinelib", @"OutlineAppleLib is not linked to the host app target", nil);
#endif
}

RCT_EXPORT_METHOD(getStatus:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
#if 1  // OutlineTunnel is directly imported above
  // Bridged async - completion handler returns BOOL active
  [[OutlineVpn shared] isActiveWithCompletion:kDefaultTunnelId completionHandler:^(BOOL active) {
    if (resolve) resolve(@(active));
  }];
#else
  if (reject) reject(@"missing_outlinelib", @"OutlineAppleLib is not linked to the host app target", nil);
#endif
}

#pragma mark - Helpers

- (void)emitStatusFromStatus:(NEVPNStatus)status tunnelId:(NSString *)tunnelId {
  if (!self.hasListeners) return;
  NSString *statusText = [self statusTextFromNEStatus:status];
  NSDictionary *payload = @{
    @"tunnelId": tunnelId ?: @"",
    @"status": @(status),
    @"statusText": statusText ?: @"unknown"
  };
  [self sendEventWithName:kEventVpnStatusChanged body:payload];
}

- (void)emitError:(NSError *)error forOperation:(NSString *)op {
  if (!self.hasListeners) return;
  NSString *code = [self errorCodeFromNSError:error];
  NSString *message = [self errorMessageFromNSError:error];
  NSDictionary *payload = @{
    @"operation": op ?: @"",
    @"code": code ?: @"",
    @"message": message ?: @"",
  };
  [self sendEventWithName:kEventVpnError body:payload];
}

- (NSString *)statusTextFromNEStatus:(NEVPNStatus)status {
  switch (status) {
    case NEVPNStatusInvalid: return @"invalid";
    case NEVPNStatusDisconnected: return @"disconnected";
    case NEVPNStatusConnecting: return @"connecting";
    case NEVPNStatusConnected: return @"connected";
    case NEVPNStatusReasserting: return @"reasserting";
    case NEVPNStatusDisconnecting: return @"disconnecting";
    default: return @"unknown";
  }
}

- (NSString *)toTransportYAML:(NSString *)input {
  if (input == nil) return @"";
  NSString *trimmed = [input stringByTrimmingCharactersInSet:NSCharacterSet.whitespaceAndNewlineCharacterSet];
  if (trimmed.length == 0) return @"";
  // Pass-through if already a YAML with "transport:" at the beginning (or anywhere)
  if ([trimmed containsString:@"\ntransport:"] || [trimmed hasPrefix:@"transport:"]) {
    return trimmed;
  }
  // If it's JSON (legacy object), wrap as YAML transport: {json...}
  if ([trimmed hasPrefix:@"{"] && [trimmed hasSuffix:@"}"]) {
    return [NSString stringWithFormat:@"transport: %@", trimmed];
  }
  // If it's an ss:// URL or quoted string, wrap as YAML.
  if ([trimmed hasPrefix:@"ss://"] || [trimmed hasPrefix:@"\"ss://"] || [trimmed hasPrefix:@"'ss://"]) {
    return [NSString stringWithFormat:@"transport: %@", trimmed];
  }
  // Fallback: try to wrap raw input as a string
  return [NSString stringWithFormat:@"transport: \"%@\"", [self yamlEscape:trimmed]];
}

- (NSString *)yamlEscape:(NSString *)s {
  // Minimal escaping for quotes/backslashes/newlines
  NSMutableString *m = [s mutableCopy];
  [m replaceOccurrencesOfString:@"\\" withString:@"\\\\"
                         options:0 range:NSMakeRange(0, m.length)];
  [m replaceOccurrencesOfString:@"\"" withString:@"\\\""
                         options:0 range:NSMakeRange(0, m.length)];
  [m replaceOccurrencesOfString:@"\n" withString:@"\\n"
                         options:0 range:NSMakeRange(0, m.length)];
  return m;
}

- (NSString *)errorCodeFromNSError:(NSError *)error {
  // OutlineError exports a domain, but fallback to code string in localizedDescription.
  NSString *code = error.userInfo[@"DetailedJsonError_ErrorCode"];
  if (code.length > 0) return code;
  return error.domain ?: @"OutlineError";
}

- (NSString *)errorMessageFromNSError:(NSError *)error {
  NSString *json = error.userInfo[@"OutlineJsonError_JsonDetails"];
  if (json.length > 0) return json;
  return error.localizedDescription ?: @"Unknown error";
}

@end