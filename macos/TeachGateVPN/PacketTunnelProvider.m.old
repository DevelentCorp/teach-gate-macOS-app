// Copyright 2018 The Outline Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#import "PacketTunnelProvider.h"
#import "TeachGateVPN-Swift.h"

#include <arpa/inet.h>
#include <ifaddrs.h>
#include <netdb.h>

@import Tun2socks;

NSString *const kDefaultPathKey = @"defaultPath";

// Simple logging replacement
#define DDLogInfo(...) NSLog(__VA_ARGS__)
#define DDLogDebug(...) NSLog(__VA_ARGS__)
#define DDLogError(...) NSLog(__VA_ARGS__)

@interface PacketTunnelProvider ()
// Properties are already declared in header file
@end

@implementation PacketTunnelProvider

- (id)init {
    self = [super init];
    
    // Initialize packet queue for VPN processing
    self.packetQueue = dispatch_queue_create("com.teachgatedesk.develentcorp.packetqueue", DISPATCH_QUEUE_SERIAL);
    
    return self;
}

- (void)startTunnelWithOptions:(NSDictionary *)options
             completionHandler:(void (^)(NSError *))completion {
    DDLogInfo(@"Starting tunnel");
    DDLogDebug(@"Options are %@", options);

    // Simple error handler
    void (^startDone)(NSError *) = ^(NSError *err) {
        completion(err);
    };

    // MARK: Process Config.
    if (self.protocolConfiguration == nil) {
        DDLogError(@"Failed to retrieve NETunnelProviderProtocol.");
        NSError *error = [NSError errorWithDomain:@"TeachGateVPN" code:1001 userInfo:@{NSLocalizedDescriptionKey: @"no config specified"}];
        return startDone(error);
    }
    NETunnelProviderProtocol *protocol = (NETunnelProviderProtocol *)self.protocolConfiguration;
    NSString *tunnelId = protocol.providerConfiguration[@"id"];
    if (![tunnelId isKindOfClass:[NSString class]]) {
        DDLogError(@"Failed to retrieve the tunnel id.");
        NSError *error = [NSError errorWithDomain:@"TeachGateVPN" code:1002 userInfo:@{NSLocalizedDescriptionKey: @"no tunnel ID specified"}];
        return startDone(error);
    }

    NSString *transportConfig = protocol.providerConfiguration[@"transport"];
    if (![transportConfig isKindOfClass:[NSString class]]) {
        DDLogError(@"Failed to retrieve the transport configuration.");
        NSError *error = [NSError errorWithDomain:@"TeachGateVPN" code:1003 userInfo:@{NSLocalizedDescriptionKey: @"config is not a String"}];
        return startDone(error);
    }
    self.tunnelId = tunnelId;
    self.transportConfig = transportConfig;

    // For minimal testing, skip connectivity checks
    BOOL isUdpSupported = YES;

    [self startRouting:[SwiftBridge getTunnelNetworkSettings]
            completion:^(NSError *_Nullable error) {
                if (error != nil) {
                    return startDone(error);
                }
                PlaterrorsPlatformError *tun2socksError = [self startTun2Socks:isUdpSupported];
                if (tun2socksError != nil) {
                    NSString *errorMsg = [NSString stringWithFormat:@"tun2socks failed: %s", tun2socksError->Message ? tun2socksError->Message : "unknown error"];
                    NSError *error = [NSError errorWithDomain:@"TeachGateVPN" code:1004 userInfo:@{NSLocalizedDescriptionKey: errorMsg}];
                    return startDone(error);
                }
                [self listenForNetworkChanges];
                startDone(nil);
            }];
}

- (void)stopTunnelWithReason:(NEProviderStopReason)reason
           completionHandler:(void (^)(void))completionHandler {
    DDLogInfo(@"Stopping tunnel, reason: %ld", (long)reason);
    [self stopListeningForNetworkChanges];
    // For testing, just clear the tunnel reference
    self.tunnel = nil;
    [self cancelTunnelWithError:nil];
    completionHandler();
}

# pragma mark - Network

- (void)startRouting:(NEPacketTunnelNetworkSettings *)settings
           completion:(void (^)(NSError *))completionHandler {
    __weak PacketTunnelProvider *weakSelf = self;
    [self setTunnelNetworkSettings:settings completionHandler:^(NSError * _Nullable error) {
        if (error != nil) {
            DDLogError(@"Failed to start routing: %@", error.localizedDescription);
        } else {
            DDLogInfo(@"Routing started");
            weakSelf.reasserting = settings == nil;
        }
        completionHandler(error);
    }];
}

// Registers KVO for the `defaultPath` property to receive network connectivity changes.
- (void)listenForNetworkChanges {
    [self stopListeningForNetworkChanges];
    [self addObserver:self
           forKeyPath:kDefaultPathKey
              options:NSKeyValueObservingOptionOld
              context:nil];
}

// Unregisters KVO for `defaultPath`.
- (void)stopListeningForNetworkChanges {
    @try {
        [self removeObserver:self forKeyPath:kDefaultPathKey];
    } @catch (id exception) {
        // Observer not registered, ignore.
    }
}

- (void)observeValueForKeyPath:(nullable NSString *)keyPath
                      ofObject:(nullable id)object
                        change:(nullable NSDictionary<NSString *, id> *)change
                       context:(nullable void *)context {
    if (![kDefaultPathKey isEqualToString:keyPath]) {
        return;
    }
    NWPath *lastPath = change[NSKeyValueChangeOldKey];
    if (lastPath == nil || [lastPath isEqualToPath:self.defaultPath] ||
        [lastPath.description isEqualToString:self.defaultPath.description]) {
        return;
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        [self handleNetworkChange:self.defaultPath];
    });
}

- (void)handleNetworkChange:(NWPath *)newDefaultPath {
    DDLogInfo(@"Network connectivity changed");
    if (newDefaultPath.status == NWPathStatusSatisfied) {
        DDLogInfo(@"Reconnecting tunnel.");
        BOOL isUdpSupported = YES; // Assume UDP support for testing
        DDLogDebug(@"UDP support: %d -> %d", self.isUdpSupported, isUdpSupported);
        self.isUdpSupported = isUdpSupported;
        [self reconnectTunnel];
    } else {
        DDLogInfo(@"Clearing tunnel settings.");
        [self startRouting:nil completion:^(NSError * _Nullable error) {
            if (error != nil) {
                DDLogError(@"Failed to clear tunnel network settings: %@", error.localizedDescription);
            } else {
                DDLogInfo(@"Tunnel settings cleared");
            }
        }];
    }
}

/**
 Converts a struct sockaddr address |sa| to a string. Expects |maxbytes| to be allocated for |s|.
 @return whether the operation succeeded.
*/
bool getIpAddressString(const struct sockaddr *sa, char *s, socklen_t maxbytes) {
    if (!sa || !s) {
        DDLogError(@"Failed to get IP address string: invalid argument");
        return false;
    }
    switch (sa->sa_family) {
        case AF_INET:
            inet_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr), s, maxbytes);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr), s, maxbytes);
            break;
        default:
            DDLogError(@"Cannot get IP address string: unknown address family");
            return false;
    }
    return true;
}

#pragma mark - tun2socks

/** Restarts tun2socks if |configChanged| or the host's IP address has changed in the network. */
- (void)reconnectTunnel {
    if (!self.transportConfig || !self.tunnel) {
        DDLogError(@"Failed to reconnect tunnel, missing tunnel configuration.");
        return;
    }
    // Nothing changed. Connect the tunnel with the current settings.
    [self startRouting:[SwiftBridge getTunnelNetworkSettings]
           completion:^(NSError *_Nullable error) {
               if (error != nil) {
                   [self cancelTunnelWithError:error];
               }
           }];
}

- (BOOL)close:(NSError *_Nullable *)error {
    return YES;
}

- (BOOL)write:(NSData *_Nullable)packet n:(long *)n error:(NSError *_Nullable *)error {
    [self.packetFlow writePackets:@[ packet ] withProtocols:@[ @(AF_INET) ]];
    return YES;
}

// Writes packets from the VPN to the tunnel.
- (void)processPackets {
    __weak typeof(self) weakSelf = self;
    __block long bytesWritten = 0;
    [weakSelf.packetFlow readPacketsWithCompletionHandler:^(NSArray<NSData *> *_Nonnull packets,
                                                            NSArray<NSNumber *> *_Nonnull protocols) {
        for (NSData *packet in packets) {
            // For testing, just log packet processing
            DDLogDebug(@"Processing packet of size: %lu", (unsigned long)packet.length);
        }
        dispatch_async(weakSelf.packetQueue, ^{
            [weakSelf processPackets];
        });
    }];
}

- (PlaterrorsPlatformError*)startTun2Socks:(BOOL)isUdpSupported {
    BOOL isRestart = self.tunnel != nil;
    if (isRestart) {
        // For testing, just clear the tunnel
        self.tunnel = nil;
    }
    __weak PacketTunnelProvider *weakSelf = self;
    
    // Get client pointer from Swift Bridge
    void* clientPointer = [SwiftBridge newClientWithId:self.tunnelId transportConfig:self.transportConfig];
    if (clientPointer == nil) {
        DDLogError(@"Failed to create Shadowsocks client");
        return nil; // Return error in production
    }
    
    // Call the Go tun2socks function - this is the critical test!
    Tun2socksConnectOutlineTunnelResult *result =
        Tun2socksConnectOutlineTunnel((__bridge void*)weakSelf, (Tun2socksClient*)clientPointer, isUdpSupported);
    if (result && result->error != nil) {
        DDLogError(@"Failed to start tun2socks");
        return result->error;
    }
    if (result && result->tunnel) {
        self.tunnel = (__bridge id)(result->tunnel);
    }
    if (!isRestart) {
        dispatch_async(self.packetQueue, ^{
            [weakSelf processPackets];
        });
    }
    return nil;
}

#pragma mark - fetch last disconnect error

- (void)handleAppMessage:(NSData *)messageData completionHandler:(void (^)(NSData * _Nullable))completion {
    NSString *ipcName = [[NSString alloc] initWithData:messageData encoding:NSUTF8StringEncoding];
    completion([@"{}" dataUsingEncoding:NSUTF8StringEncoding]);
}

- (void)cancelTunnelWithError:(nullable NSError *)error {
    [super cancelTunnelWithError:error];
}

@end
